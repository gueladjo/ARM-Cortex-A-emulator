/**
 * @file memory.c
 * @author Mickael Albisser
 * @brief Memory + registers management functions
 */


#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <inttypes.h>

typedef uint8_t byte;
typedef uint32_t word;

typedef struct
{
  byte* raddr; //Real address, beginning of segment
  size_t size; //Segment size
  size_t vaddr; //Virtual address, beginning of segment
} segment;

typedef struct
{
  segment* stack;
  segment* bss;
  segment* data;
  segment* txt;
  segment* rodata;
} memory;

/**
 * Sets the stack
 * @reg the array representing the registers to initiate the stack pointer
 * @mem the structure representing the memory where the stack will be
 * @return the memory
 */
memory stack_set (word* reg, memory mem);

/**
 * Allocates the memory for the different segments,
 * knowing their sizes (in bytes)
 * @rodata_size size of segment rodata
 * @txt_size size of segment txt
 * @data_size size of segment data
 * @bss_size size of segment bss
 * @return the memory structure
 */

memory memory_allocation(memory mem, char* section_name, size_t size, size_t adress);

/**
 * Returns value stored at the address addr
 * Looks in each segment if the address is there,
 * and if case, returns the value. Returns NULL if
 * address does not exist
 * @addr the searched address
 * @mem the structure containing the memory
 * @return the value stored
 */
byte read_memory_value(size_t addr, memory mem);

/**
 * Change the value stored at the address addr
 * It's the exact reverse operation as before
 * it works almost the same way. Returns 0 if
 * the address exist and could be changed, 
 * 1 in the other case
 * @addr the searched address
 * @value the value to replace the precedent one
 * @mem the memory
 * @return an int allowing to check errors
 */
int write_memory_value(size_t addr, byte value, memory mem);

/**
 * Frees the memory. Returns 0 in case of success,
 * 1 if nothing has been freed
 * @mem the memory
 * @return an int to check errors
 */
int memory_free(memory mem);


memory stack_set(word* reg, memory mem)
{
  mem.stack = malloc(sizeof(segment));
  mem.stack->vaddr = 0xff7ff000;
  mem.stack->size = 0x00800000; //Stack size
  mem.stack->raddr = calloc(mem.stack->size, sizeof(byte));
  reg[13] = 0xfffff000; //sp points the first address of the stack
  return mem;
}


memory memory_allocation(memory mem, char* section_name, byte* segdata, size_t size, size_t adress)
{
  if (size == 0) return mem;

  if (section_name = ".rodata") {
    mem.rodata = malloc(sizeof(segment));
    mem.rodata->raddr = calloc(size, sizeof(byte));
    mem.rodata->vaddr = adress;
    mem.rodata->size = size;
    mem.rodata->raddr = memcpy(mem.rodata->raddr, segdata, size);
    return mem;
  }
  if (section_name = ".text") {
    mem.txt = malloc(sizeof(segment));
    mem.txt->raddr = calloc(size, sizeof(byte));
    mem.txt->vaddr = adress; 
    mem.txt->size = size;
    mem.txt->raddr = memcpy(mem.txt->raddr, segdata, size);
    return mem;
  }
  if (section_name = ".data") {
    mem.data = malloc(sizeof(segment));
    mem.data->raddr = calloc(size, sizeof(byte));
    mem.data->vaddr = adress;
    mem.data->size = size;
    mem.data->raddr = memcpy(mem.data->raddr, segdata, size);
    return mem;
  }
  if (section_name = ".bss") {
    mem.bss = malloc(sizeof(segment));
    mem.bss->raddr = calloc(size, sizeof(byte));
    mem.bss->vaddr = adress;
    mem.bss->size = size;
    mem.bss->raddr = memcpy(mem.bss->raddr, segdata, size);
    return mem;
  }
  return mem;
}


byte read_memory_value(size_t addr, memory mem)
{
  //For each segment, checks if the address is there, and returns the value stored in the cell
  byte value = NULL; 
  size_t offset;
  if (mem.rodata!=NULL && addr > mem.rodata->vaddr && addr < mem.rodata->vaddr + mem.rodata->size) {
    offset = addr - mem.rodata->vaddr;
    value = *(mem.rodata->raddr + offset);
  }
  else if (mem.txt!=NULL && addr > mem.txt->vaddr && addr < mem.txt->vaddr + mem.txt->size) {
    offset = addr - mem.txt->vaddr;
    value = *(mem.txt->raddr + offset);
  }
  else if (mem.data!=NULL && addr > mem.data->vaddr && addr < mem.data->vaddr + mem.data->size) {
    offset = addr - mem.data->vaddr;
    value = *(mem.data->raddr + offset);
 }
  else if (mem.bss!=NULL && addr > mem.bss->vaddr && addr < mem.bss->vaddr + mem.bss->size) {
    offset = addr - mem.bss->vaddr;
    value = *(mem.bss->raddr + offset);
  }
  else if (mem.stack!=NULL && addr > mem.stack->vaddr && addr < mem.stack->vaddr + mem.stack->size) {
    offset = addr - mem.stack->vaddr;
    value = *(mem.stack->raddr + offset);
  }
  return value;
}


int write_memory_value(size_t addr, byte value, memory mem)
{
  //For each segment, checks if the address is there, and changes the value stored in the cell
  int e = 1; //Error value
  size_t offset;
  if (mem.rodata!=NULL && addr > mem.rodata->vaddr && addr < mem.rodata->vaddr + mem.rodata->size) {
    offset = addr - mem.rodata->vaddr;
    *(mem.rodata->raddr + offset) = value;
    e = 0;
  }
  else if (mem.txt!=NULL && addr > mem.txt->vaddr && addr < mem.txt->vaddr + mem.txt->size) {
    offset = addr - mem.txt->vaddr;
    *(mem.txt->raddr + offset) = value;
    e = 0;
  }
  else if (mem.data!=NULL && addr > mem.data->vaddr && addr < mem.data->vaddr + mem.data->size) {
    offset = addr - mem.data->vaddr;
    *(mem.data->raddr + offset) = value;
    e = 0;
 }
  else if (mem.bss!=NULL && addr > mem.bss->vaddr && addr < mem.bss->vaddr + mem.bss->size) {
    offset = addr - mem.bss->vaddr;
    *(mem.bss->raddr + offset) = value;
    e = 0;
  }
  else if (mem.stack!=NULL && addr > mem.stack->vaddr && addr < mem.stack->vaddr + mem.stack->size) {
    offset = addr - mem.stack->vaddr;
    *(mem.stack->raddr + offset) = value;
    e = 0;
  }
  return e;
}


int memory_free(memory mem)
{
  int e = 1; //Error value
  if (mem.rodata->size != 0) {
    free(mem.rodata->raddr);
    free(mem.rodata);
    e = 0;
  }
  if (mem.txt->size != 0) {
    free(mem.txt->raddr);
    free(mem.txt);
    e = 0;
  }
  if (mem.data->size != 0) {
    free(mem.data->raddr);
    free(mem.data);
    e = 0;
  }
  if (mem.bss->size != 0) {
    free(mem.bss->raddr);
    free(mem.bss);
    e = 0;
  }
  if (mem.stack->size != 0) {
    free(mem.stack->raddr);
    free(mem.stack);
    e = 0;
  }
  return e;
}
